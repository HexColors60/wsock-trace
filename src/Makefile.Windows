#
# GNU Makefile for Wsock-trace (MinGW, MSVC, Clang-CL and Cygwin, 32 and 64-bit).
#
# By <gvanem@yahoo.no> 2018 - 2020.
#

DATE := $(shell date +%d-%B-%Y)

THIS_FILE = Makefile.Windows

#
# Root directories to various stuff used below.
#
MINGW_ROOT    := $(realpath $(MINGW32))
TDM_GCC_ROOT  := $(realpath $(MINGW_TDM))
MSVC_ROOT     := $(realpath $(VCToolkitInstallDir))
VC_ROOT       := $(realpath $(VSINSTALLDIR))
CYGWIN32_ROOT := $(realpath $(CYGWIN32_ROOT))
CYGWIN64_ROOT := $(realpath $(CYGWIN64_ROOT))
CLANG32_ROOT  := f:/ProgramFiler/LLVM-10-32bit
CLANG64_ROOT  := f:/ProgramFiler/LLVM-10-64bit

#
# Use libbfd.a to resolve debug symbols.
# For MinGW/Cygwin only.
#
USE_BFD ?= 0

#
# If you want Lua-script support:
#
USE_LUA    ?= 1
LUAJIT_ROOT = ../LuaJIT

#
# If you want lwIP support, you may have to change these:
#
USE_LWIP  ?= 0
LWIP_ROOT ?= $(MINGW_ROOT)/src/inet/lwip
PCAP_ROOT ?= $(MINGW_ROOT)/src/inet/libpcap

#
# Use GNU 'indent', 'clang-format' or not in the below C-preprocess rule?
# Ref: '%.i: %.c' below.
#
USE_GNU_INDENT   ?= 0
USE_CLANG_FORMAT ?= 1

#
# Build a debugable version.
#
USE_CRT_DEBUG ?= 0

#
# Use a static CRT (MSVC/clang-cl only).
#
USE_CRT_STATIC ?= 0

#
# Use maximum warnings for 'clang-cl'.
#
USE_MAX_WARNINGS ?= 0

#
# Use and older VC-2010 or VC-2013 instead.
#
USE_OLD_VISUALC ?= 0

#
# Use the experimental Address Sanitizer (ASAN) in MSVC 16.7.
#
USE_SANITIZE ?= 0

#
# If '$(CPU)=x64', build 64-bit targets. Otherwise 32-bit targets.
#
ifeq ($(CPU),)
  CPU = x86
endif

#
# GNU Make handles environment variables in a case-sensitive manner.
#
ifeq ($(CPU),X64)
  BITS     = 64
  X_SUFFIX = _x64
else ifeq ($(CPU),x64)
  BITS     = 64
  X_SUFFIX = _x64
else ifeq ($(CPU),x86)
  BITS     = 32
  X_SUFFIX =
else ifeq ($(CPU),X86)
  BITS     = 32
  X_SUFFIX =
else
  $(error Unsupported $$(CPU)=$(CPU))
endif

export CL=

#
# Change paths to suite your setup:
#
ifeq ($(USE_OLD_VISUALC),1)
  CL_CC   = $(realpath $(VC_OLD_BASE))/bin/cl.exe
  CL_LINK = $(realpath $(VC_OLD_BASE))/bin/link.exe
  CRT_DIR = $(realpath $(VC_OLD_BASE))/lib

  COMPILER_PATH = $(subst /,\,$(VC_OLD_BASE)/bin)

else
  #
  # For Visual-Studio 2017+
  #
  CL_CC   = $(MSVC_ROOT)/bin/HostX86/$(CPU)/cl.exe
  CL_LINK = $(MSVC_ROOT)/bin/HostX86/$(CPU)/link.exe
  CRT_DIR = $(MSVC_ROOT)/lib/$(CPU)

  COMPILER_PATH = $(subst /,\,$(MSVC_ROOT)/bin/HostX86/$(CPU))
endif

#
# Where to copy $(TARGETS) to.
#
ifeq ($(TARGET),MinGW)
  INSTALL_BIN = $(MINGW_ROOT)/bin
  INSTALL_LIB = $(MINGW_ROOT)/lib

else ifeq ($(TARGET),Cygwin)
  ifeq ($(CPU),x64)
    INSTALL_BIN = $(CYGWIN64_ROOT)/bin
    INSTALL_LIB = $(CYGWIN64_ROOT)/lib
  else
    INSTALL_BIN = $(CYGWIN32_ROOT)/bin
    INSTALL_LIB = $(CYGWIN32_ROOT)/lib
  endif

else
  #
  # MSVC + clang-cl
  #
  INSTALL_BIN = $(VC_ROOT)/bin
  INSTALL_LIB = $(VC_ROOT)/lib
endif

define USAGE

  Usage: "$(MAKE) -f $(THIS_FILE) <CPU=x86|x64> TARGET=[MSVC | clang | MinGW | Cygwin] [all | clean | realclean | install]"
  Specify TARGET=MSVC
  Specify TARGET=clang
  Specify TARGET=MinGW
  Specify TARGET=Cygwin
endef

#
# This is either a 32-bit or 64-bit clang-cl
#
ifeq ($(CPU),x64)
  CLANG_CC = $(CLANG64_ROOT)/bin/clang-cl.exe
else
  CLANG_CC = $(CLANG32_ROOT)/bin/clang-cl.exe
endif

#
# The following codes used in macro 'colour_msg' assumes you have
# MSys/Cygwin's echo with colour support.
#
BRIGHT_RED    = \e[1;31m
BRIGHT_GREEN  = \e[1;32m
BRIGHT_YELLOW = \e[1;33m

colour_msg = @echo -e "$(1)\e[0m"
red_msg    = $(call colour_msg,$(BRIGHT_RED)$(strip $(1)))
green_msg  = $(call colour_msg,$(BRIGHT_GREEN)$(strip $(1)))

default: all

#
# Some checks for required tools
#
path_find  = $(word 1, $(wildcard $(addsuffix /$(1),$(subst ;, ,$(subst \,/,$(PATH))))))
file_exist = $(wildcard $(1))

define check_MinGW
  $(info Assuming $(GCC_CC) is okay for $(BITS)-bit.)
endef

define check_Cygwin
  $(info Assuming $(GCC_CC) is okay for $(BITS)-bit.)
endef

ifeq ($(call file_exist,$(CL_CC)),)
  define check_MSVC
    $(error "$(CL_CC)" not found. Edit $(THIS_FILE) manually)
  endef
else
  define check_MSVC
    $(info Assuming $(CL_CC) is okay for $(BITS)-bit.)
  endef
endif

ifeq ($(call file_exist,$(CLANG_CC)),)
  define check_clang
    $(error "$(CLANG_CC)" not found on path. Edit $(THIS_FILE) manually)
  endef
else
  define check_clang
    $(info Assuming $(CLANG_CC) is okay for $(BITS)-bit.)
  endef
endif

#
# CFLAGS, LDFLAGS and RCFLAGS for MSVC + clang-cl:
#
CL_CFLAGS  = -nologo -D_CRT_SECURE_NO_WARNINGS -D_WINSOCK_DEPRECATED_NO_WARNINGS -Zi -Oy- # -GF
CL_LDFLAGS = -nologo -subsystem:console -verbose -incremental:no -map -debug -machine:$(CPU)
CL_RCFLAGS = -nologo -DBITNESS=$(BITS)

ifeq ($(USE_OLD_VISUALC),1)
  CL_CFLAGS += -I$(realpath $(VC_OLD_BASE))/include
else
  CL_CFLAGS += -Zo

  ifeq ($(USE_SANITIZE),1)
    ifeq ($(CPU),x64)
      $(error 'USE_SANITIZE=1' is not available for 'x64')
    endif

    CL_CFLAGS    += -fsanitize=address
    WHOLE_ARCHIVE = -wholearchive:$(WSOCK_LIB)

    ifeq ($(USE_CRT_STATIC),1)
      EX_LIBS += clang_rt.asan-i386.lib
    else
      EX_LIBS += clang_rt.asan_dynamic-i386.lib clang_rt.asan_dynamic_runtime_thunk-i386.lib
    endif
  endif
endif

#
# For MSVC-2017 only:
#   Speculative execution attack mitigation
#   Ref: https://blogs.msdn.microsoft.com/vcblog/2018/01/15/spectre-mitigations-in-msvc/
#
ifeq ($(USE_CRT_DEBUG),0)
  # CL_CFLAGS += -Qspectre
endif

ifeq ($(TARGET),clang)
  CL_RCFLAGS += -D__clang__
else
  CL_RCFLAGS += -D_MSC_VER
endif

#
# The path for the CRT library (msvcrt.lib):
#
CL_LDFLAGS += -libpath:$(CRT_DIR) -nodefaultlib:oldnames.lib,uuid.lib

#
# 'WindowsKits' root is in $(WK_ROOT) and
# 'WindowsKits' version is in $(WK_VER).
#
# Hence the "User-Mode" Windows libraries for 'x86' are in:
#   $(WK_ROOT)/Lib/$(WK_VER)/um/x86/
#
CL_LDFLAGS += -libpath:$(realpath $(WK_ROOT)/Lib/$(WK_VER)/um/$(CPU))

#
# Ditto mess for the Universal CRT libraries: for 'x86' the UCRT libs are in:
#   $(WK_ROOT)/Lib/$(WK_VER)/ucrt/x86/
#
CL_LDFLAGS += -libpath:$(realpath $(WK_ROOT)/Lib/$(WK_VER)/ucrt/$(CPU))

ifeq ($(USE_CRT_STATIC),1)
  CL_MD = -MT
else
  CL_MD = -MD
endif

ifeq ($(USE_CRT_DEBUG),1)
  CL_CFLAGS  += $(CL_MD)d -Ob0 -RTCs -RTCu -GS -Gs
  CL_RCFLAGS += -DDEBUG
else
  CL_CFLAGS += $(CL_MD) -Ot -GS-
endif

#
# CFLAGS, LDFLAGS for MinGW. This assumes TDM-gcc or MinGW-w64 with
# dual-target support ('-m32' and '-m64').
#
ifeq ($(TARGET),MinGW)
  GCC_CC = $(TDM_GCC_ROOT)/bin/gcc.exe -m$(BITS)
  GCC_LD = $(TDM_GCC_ROOT)/bin/gcc.exe -m$(BITS)

else ifeq ($(TARGET),Cygwin)
  #
  # Select correct 'gcc' for Cygwin depending on $(CPU)'
  #
  ifeq ($(CPU),x64)
    GCC_CC = $(CYGWIN64_ROOT)/bin/gcc.exe
  else
    GCC_CC = $(CYGWIN32_ROOT)/bin/gcc.exe
  endif
endif

GCC_CFLAGS  = -Wall -fmax-errors=5
GCC_LDFLAGS = -Wl,--print-map,--sort-common,--cref

#
# No need to have '-D__MINGW32__' or '-D__CYGWIN__' on windres
# cmd-line as 'gcc' is used to pre-process it.
#
GCC_RCFLAGS = -O COFF -DBITNESS=$(BITS)

ifeq ($(BITS),32)
  GCC_RCFLAGS += --target=pe-i386
else
  GCC_RCFLAGS += --target=pe-x86-64
endif

ifeq ($(USE_CRT_DEBUG),1)
  GCC_CFLAGS  += -ggdb -O0 -D_DEBUG
  GCC_RCFLAGS += -DDEBUG
else
  GCC_CFLAGS  += -O3 -ggdb -fomit-frame-pointer
  GCC_LDFLAGS += # -s
endif

#
# MSVC:
#
ifeq ($(TARGET),MSVC)
  #
  # The 'cl.exe' compiler used in the below C-preprocess rule ('%.i: %.c') is
  # important. The output depends highly on whether '_WIN64' and/or '_M_X64'
  # is defined or not. These are built-in defines.
  #
  CPP_CMD = $(CL_CC)
  CFLAGS  = $(CL_CFLAGS) -W3

  WSOCK_DLL = wsock_trace$(X_SUFFIX).dll
  WSOCK_LIB = wsock_trace$(X_SUFFIX).lib
  IS_GCC    = 0

else ifeq ($(TARGET),clang)
  CPP_CMD = clang-cl
  CL_CC   = $(CLANG_CC)
  CFLAGS  = $(CL_CFLAGS) -Wall -ferror-limit=5

  ifeq ($(USE_MAX_WARNINGS),0)
    CFLAGS += -Wno-missing-braces                \
              -Wno-unused-function               \
              -Wno-cast-align                    \
              -Wno-cast-qual                     \
              -Wno-pedantic                      \
              -Wno-date-time                     \
              -Wno-shift-sign-overflow           \
              -Wno-sign-compare                  \
              -Wno-unreachable-code-break        \
              -Wno-format-nonliteral             \
              -Wno-format-non-iso                \
              -Wno-undef                         \
              -Wno-covered-switch-default        \
              -Wno-missing-prototypes            \
              -Wno-conversion                    \
              -Wno-bad-function-cast             \
              -Wno-double-promotion              \
              -Wno-unused-macros                 \
              -Wno-missing-noreturn              \
              -Wno-missing-field-initializers    \
              -Wno-missing-variable-declarations \
              -Wno-documentation-unknown-command \
            # -Wno-switch-enum
  endif

  ifeq ($(USE_OLD_VISUALC),1)
    CFLAGS += -Wno-unused-local-typedef \
              -Wno-shadow
  endif

  CFLAGS += -Wno-reserved-id-macro               \
            -Wno-language-extension-token        \
            -Wno-nonportable-system-include-path \
            -Wno-invalid-source-encoding         \
            -Wno-gnu-zero-variadic-macro-arguments

  WSOCK_DLL = wsock_trace$(X_SUFFIX).dll
  WSOCK_LIB = wsock_trace$(X_SUFFIX).lib
  IS_GCC    = 0

else ifeq ($(TARGET),MinGW)
  CPP_CMD = $(GCC_CC)
  CFLAGS  = $(GCC_CFLAGS) -DWANT_ISDEBUGGERPRESENT_WRAPPER

  WSOCK_DLL = wsock_trace_mw$(X_SUFFIX).dll
  WSOCK_LIB = libwsock_trace$(X_SUFFIX).a
  IS_GCC    = 1

else ifeq ($(TARGET),Cygwin)
  CPP_CMD = $(GCC_CC)
  CFLAGS  = $(GCC_CFLAGS) -D__USE_W32_SOCKETS

  WSOCK_DLL = wsock_trace_cyg$(X_SUFFIX).dll
  WSOCK_LIB = libwsock_trace$(X_SUFFIX).a
  IS_GCC    = 1

else
  $(error $(USAGE))
endif

OBJ_DIR = $(TARGET)_obj

ifeq ($(IS_GCC),1)
  O       = o
  WS2_32  = -lws2_32
  WIN_MM  = -lwinmm
  EX_LIBS = -lole32 -ladvapi32

else
  O        = obj
  WS2_32   = ws2_32.lib
  WIN_MM   = winmm.lib
  EX_LIBS += ole32.lib advapi32.lib
  USE_BFD  = 0
endif

CFLAGS += -D_WIN32_WINNT=0x0600 -DWIN32_LEAN_AND_MEAN -DUSE_DEF_FILE

TARGETS = $(WSOCK_DLL) $(WSOCK_LIB)

include Makefile.inc

ifeq ($(USE_BFD),1)
  CFLAGS    += -DUSE_BFD -DBFD_ARCH_SIZE=$(BITS)
  EX_LIBS   += -lbfd -liberty -lintl -lz
  WSOCK_SRC += bfd_gcc.c
endif

ifeq ($(USE_LUA),1)
  CFLAGS += -DUSE_LUA -I$(LUAJIT_ROOT)/src

  ifeq ($(IS_GCC),1)
    LUAJIT_LIB = $(LUAJIT_ROOT)/src/libluajit$(BITS).a
  else
    LUAJIT_LIB = $(LUAJIT_ROOT)/src/lua51_static$(BITS).lib
  endif

  LUAJIT_OBJ = $(OBJ_DIR)/ljamalg.$(O)
endif

ifeq ($(USE_LWIP),1)
  CFLAGS    += -DUSE_LWIP -DNO_SYS=1      \
               -I$(LWIP_ROOT)/src/include \
               -I$(LWIP_ROOT)/src/contrib \
               -I$(LWIP_ROOT)/src/include/Win32-specials
  WSOCK_SRC += wsock_trace_lwip.c

  ifeq ($(IS_GCC),1)
    EX_LIBS += $(LWIP_ROOT)/liblwip$(BITS).a $(PCAP_ROOT)/libwpcap.dll.a
  else
    EX_LIBS += $(LWIP_ROOT)/lwip$(BITS).lib $(PCAP_ROOT)/wpcap_imp.lib
  endif
endif

WSOCK_OBJ = $(addprefix $(OBJ_DIR)/, $(WSOCK_SRC:.c=.$(O)))

PROGRAMS = test.exe geoip.exe bt_test.exe idna.exe firewall_test.exe # wx-stkwalk.exe

all: $(call check_$(TARGET)) $(OBJ_DIR) $(TARGETS) $(PROGRAMS) epilogue

epilogue:
	$(call green_msg, Welcome to wsock_trace $(BRIGHT_YELLOW)(TARGET=$(TARGET), $(BITS)-bits).)
	$(call green_msg, Do a $(BRIGHT_YELLOW)make TARGET=$(TARGET) -f $(THIS_FILE) install$(BRIGHT_GREEN) at own risk.)

$(OBJ_DIR):
	- mkdir $(OBJ_DIR)

install: all copy_bin_$(TARGET)
	cp --update $(WSOCK_LIB) $(INSTALL_LIB)

.PHONY: copy_bin_MinGW copy_bin_Cygwin copy_bin_MSVC copy_bin_clang

copy_bin_MinGW copy_bin_Cygwin:
	cp --update $(WSOCK_DLL) $(INSTALL_BIN)

copy_bin_MSVC copy_bin_clang:
	cp --update $(WSOCK_DLL) $(WSOCK_DLL:.dll=.pdb) $(INSTALL_BIN)

#
# Make a .def file for x64; remove the leading '_' and the '@x' suffixes.
#
wsock_trace_x64.def wsock_trace_mw_x64.def wsock_trace_cyg_x64.def: wsock_trace.def $(THIS_FILE)
	echo "; This file has been generated by $(THIS_FILE)."  > $@
	echo "; DO NOT EDIT!"                                  >> $@
	sed -e "s/LIBRARY wsock_trace.dll/LIBRARY $(@:.def=.dll)/" \
	    -e "s/^ _\(.*\)@.*/ \1/g" < $< >> $@

#
# And for MinGW/Cygwin x86; remove the leading '_'.
#
wsock_trace_mw.def wsock_trace_cyg.def: wsock_trace.def $(THIS_FILE)
	echo "; This file has been generated by $(THIS_FILE)." > $@
	echo "; DO NOT EDIT!"                                 >> $@
	sed -e "s/LIBRARY wsock_trace.dll/LIBRARY $(@:.def=.dll)/" \
        -e "s/^ _\(.*\)/ \1/g" < $< >> $@

$(WSOCK_LIB): $(WSOCK_DLL)

#
# The $(WSOCK_LIB) is an import-lib for $(WSOCK_DLL).
# Since the SDK header <ws2ipdef.h> declares some data with no export
# declaration ('in6addr_any' etc.), the non-export.obj is simply added to the
# $(WSOCK_LIB) after linking is done.
#
$(WSOCK_DLL): $(WSOCK_DLL:.dll=.def) $(WSOCK_OBJ) $(OBJ_DIR)/non-export.$(O) $(OBJ_DIR)/wsock_trace.res compile_lua_$(USE_LUA)
	$(call link_DLL, $@, $(WSOCK_LIB), $<, $(WSOCK_OBJ) $(OBJ_DIR)/wsock_trace.res)
ifeq ($(IS_GCC),1)
	ar rs $(WSOCK_LIB) $(OBJ_DIR)/non-export.o
else
	lib -nologo $(WSOCK_LIB) $(OBJ_DIR)/non-export.obj
endif

#
# Experiment:
#   Building $(WSOCK_DLL) with '-Ox' (maximum optimisation) breaks in 'RtlCaptureStackBackTrace()'.
#   Check if it breaks an application too.
#
ifeq ($(TARGET),MSVC)
  ifeq ($(USE_CRT_DEBUG),0)
    $(OBJ_DIR)/test.$(O): CFLAGS += -Ox
  endif
endif

test.exe: $(OBJ_DIR)/test.$(O) $(OBJ_DIR)/getopt.$(O) $(WSOCK_LIB)
	$(call link_EXE, $@, $^)

bt_test.exe: $(BT_TEST_OBJ) $(LUAJIT_LIB) # $(LUAJIT_OBJ)
	$(call link_EXE, $@, $^ $(WS2_32))

$(OBJ_DIR)/bt_test.$(O): backtrace.c
	$(call Compile, -DTEST_BACKTRACE $<, $@)

#
# The '$(WIN_MM)' library could be needed for the 'sndPlaySound()' function.
#
firewall_test.exe: $(FIREWALL_TEST_OBJ)
	$(call link_EXE, $@, $^ $(WS2_32) $(WIN_MM))

idna.exe: $(OBJ_DIR)/idna_1.$(O) $(OBJ_DIR)/getopt.$(O) $(OBJ_DIR)/common.$(O) $(OBJ_DIR)/smartlist.$(O) $(WSOCK_LIB)
	$(call link_EXE, $@, $^)

wx-stkwalk.exe: $(OBJ_DIR)/wx-stkwalk.$(O)
	$(call link_EXE, $@, $^)

geoip.exe: $(GEOIP_OBJ)
	$(call link_EXE, $@, $^ $(WS2_32))
	geoip.exe -4g geoip-gen4.c
	geoip.exe -6g geoip-gen6.c
	$(call Compile, geoip-gen4.c, $(OBJ_DIR)/geoip-gen4.$(O))
	$(call Compile, geoip-gen6.c, $(OBJ_DIR)/geoip-gen6.$(O))
	$(call link_EXE, $@, $(COMMON_OBJ) $(OBJ_DIR)/geoip_1.$(O) $(OBJ_DIR)/ip2loc_1.$(O) $(OBJ_DIR)/geoip-gen4.$(O) $(OBJ_DIR)/geoip-gen6.$(O) $(WS2_32))

geoip-gen4.c geoip-gen6.c: geoip.exe

$(OBJ_DIR)/firewall_1.$(O): firewall.c
	$(call Compile, -DTEST_FIREWALL $<, $@)

$(OBJ_DIR)/geoip_1.$(O): geoip.c
	$(call Compile, -DTEST_GEOIP $<, $@)

$(OBJ_DIR)/ip2loc_1.$(O): ip2loc.c
	$(call Compile, -DTEST_GEOIP $<, $@)

$(OBJ_DIR)/idna_1.$(O): idna.c
	$(call Compile, -DTEST_IDNA $<, $@)

$(OBJ_DIR)/init_1.$(O): init.c
	$(call Compile, -DTEST_GEOIP $<, $@)

$(OBJ_DIR)/init_2.$(O): init.c
	$(call Compile, -DTEST_BACKTRACE $<, $@)

$(OBJ_DIR)/init_3.$(O): init.c
	$(call Compile, -DTEST_FIREWALL $<, $@)

$(OBJ_DIR)/wx-stkwalk.$(O): wx-stkwalk.cpp
	$(call CPP_compile, -DUNICODE -D_UNICODE -DTEST_WX_STKWALK $<, $@)

$(OBJ_DIR)/%.$(O): %.c
	$(call Compile, $<, $@)

$(OBJ_DIR)/%.res: %.rc
	$(call make_res, $<, $@)

compile_lua_0:
	$(call red_msg, Not compiling Lua.)

ifeq ($(TARGET),MinGW)
compile_lua_1:
	$(MAKE) -C $(LUAJIT_ROOT)/src HOST_CC='$(GCC_CC) -m$(BITS)' all ; \
	cp --update $(LUAJIT_ROOT)/src/libluajit.a $(LUAJIT_LIB)

else ifeq ($(TARGET),Cygwin)
compile_lua_1:
	$(MAKE) -C $(LUAJIT_ROOT)/src HOST_CC='$(GCC_CC)' all ; \
	cp --update $(LUAJIT_ROOT)/src/libluajit.a $(LUAJIT_LIB)

else
compile_lua_1: compile_lua_$(BITS)bit.bat
	cmd.exe /c $<
#	$(call Compile, $(LUAJIT_ROOT)/src/ljamalg.c, $(OBJ_DIR)/ljamalg.obj)

compile_lua_$(BITS)bit.bat: $(THIS_FILE)
	$(call green_msg, Generating $@...)
	$(file > $@,$(COMPILE_LUA_BAT))

#
# Write out this as 'compile_lua_$(BITS)bit.bat' and use 'cmd.exe' to invoke it.
# Only used if 'TARGET' == 'MSVC' or 'TARGET' == 'clang'.
#
# ifeq ($(TARGET),MSVC)
#
  # LuaJIT for MSVC/clang-cl is *always* compiled with 'cl'.
  # Ref. $(LUAJIT_ROOT)/src/msvcbuild.bat'.
  #
  # COMPILER_PATH = $(subst /,\,$(dir $(CL_CC)))

  #
  # The path for mspdb140.dll.
  #
  IDE_PATH = $(subst /,\,$(VS140COMNTOOLS)/../IDE)
# else
#   COMPILER_PATH = $(subst /,\,$(dir $(CLANG_CC)))
#   IDE_PATH      =
# endif


define COMPILE_LUA_BAT
  ::
  :: DO NOT EDIT! This file was generated automatically
  :: from $(realpath $(THIS_FILE)).
  :: Edit that file instead.
  ::
  :: TARGET=$(TARGET), BITS=$(BITS).
  ::
  @echo off
  setlocal
  set PROMPT=$$P$$G
  set LUA_SRC=$(subst /,\,$(LUAJIT_ROOT))\src
  set LIB=
  pushd %LUA_SRC%
  if exist $(notdir $(LUAJIT_LIB)) (
    echo %LUA_SRC%\lua51_static$(BITS).lib already exists.
  ) else (
    rem
    rem Hacks to bypass the 'vcvarsall.bat x64' or 'setenv /debug /x64' nonsense.
    rem Use the correct directories for .lib-files depending on $$(BITS) bit.
    rem
    set LIB=$(CRT_DIR);$(realpath $(WK_ROOT)/Lib/$(WK_VER)/um/$(CPU));$(realpath $(WK_ROOT)/Lib/$(WK_VER)/ucrt/$(CPU))
    set PATH=$(COMPILER_PATH);$(IDE_PATH)

    call msvcbuild.bat debug static
    if errorlevel == 0 (
      copy lua51.lib lua51_static$(BITS).lib
    ) else (
      echo msvcbuild.bat failed
    )
  )
endef
endif  # ifeq ($(TARGET),MinGW)

clean: clean_$(TARGET)
	rm -f $(OBJ_DIR)/* geoip-gen4.c geoip-gen6.c compile_lua_32bit.bat compile_lua_64bit.bat

clean_MinGW:
	rm -f wsock_trace_mw.def wsock_trace_mw_x64.def

clean_Cygwin:
	rm -f wsock_trace_cyg.def wsock_trace_cyg_x64.def

clean_MSVC clean_clang:
	rm -f $(WSOCK_DLL:.dll=.pdb) $(PROGRAMS:.exe=.pdb) wsock_trace_x64.def vc1*.pdb

realclean vclean: clean
	rm -f $(TARGETS) $(WSOCK_DLL:.dll=.map) $(PROGRAMS) $(PROGRAMS:.exe=.map)
	- rmdir $(OBJ_DIR)

REPLACE = -e 's@\(.*\)\.o: @\n$$(OBJ_DIR)\/\1.$$(O): @' \
          -e 's@$(OBJ_DIR)@$$(OBJ_DIR)@'                \
          -e 's@$(LUAJIT_ROOT)@$$(LUAJIT_ROOT)@'

#
# Command to generate a nicer C preprocessed output
# with the help of 'cpp_filter.py' and optionally 'GNU indent' or 'clang-format'.
#
ifeq ($(USE_GNU_INDENT),1)
  C_FORMATER = | indent -st
else ifeq ($(USE_CLANG_FORMAT),1)
  C_FORMATER = | clang-format -style=Mozilla -assume-filename=c
else
  C_FORMATER =
endif

%.i: %.c FORCE cpp_filter.py
	$(CPP_CMD) -E $(CFLAGS) $< | python cpp_filter.py $(C_FORMATER) > $@
	@echo

FORCE:

#
# GNU-make macros.
#
# First for MinGW / Cygwin: 'gcc'
#
ifeq ($(IS_GCC),1)
  #
  # Compile a .c-file:
  #  arg1 = $(1): the .c-file + any extra CFLAGS.
  #  arg2 = $(2): the .$(O)-file
  #
  define Compile
    $(GCC_CC) -c $(CFLAGS) -o $(2) $(1)
    @echo
  endef

  define CPP_compile
    $(GCC_CC) -x c++ -c $(CFLAGS) -o $(2) $(1)
    @echo
  endef

  #
  # Link a .exe-file:
  #  arg1 = $(1): the .exe-file
  #  arg2 = $(2): the .obj-files + any extra libraries
  #
  define link_EXE
    $(call green_msg, Linking $(1))
    $(GCC_CC) $(GCC_LDFLAGS) -o $(1) $(2) $(EX_LIBS) > $(1:.exe=.map)
    @echo
  endef

  #
  # Link a .dll-file:
  #  arg1 = $(1): the .dll-file
  #  arg2 = $(2): the import library
  #  arg3 = $(3): the .def-file
  #  arg4 = $(4): the objects, resource-file etc.
  #
  comma := ,
  define link_DLL
    $(call green_msg, Linking $(1))
    $(GCC_CC) -shared $(GCC_LDFLAGS) -o $(1) -Wl,--out-implib$(comma)$(strip $(2)) \
              $(3) $(4) $(LUAJIT_LIB) $(EX_LIBS) > $(1:.dll=.map)
    @echo
  endef

  #
  # Create a .res-file:
  #  arg1 = $(1): the input .rc-file.
  #  arg2 = $(2): the output .res-file.
  #
  define make_res
    windres $(GCC_RCFLAGS) -fo $(2) $(1)
    @echo
  endef

else
  #
  # and the same for 'TARGET = [MSVC | clang]'.
  #
  define Compile
    $(CL_CC) -c $(CFLAGS) -Fo./$(strip $(2)) $(1)
    @echo
  endef

  define CPP_compile
    $(CL_CC) -EHsc -c $(CFLAGS) -Fo./$(strip $(2)) $(1)
    @echo
  endef

  define link_EXE
    $(call green_msg, Linking $(1))
    $(CL_LINK) $(CL_LDFLAGS) $(WHOLE_ARCHIVE) -out:$(strip $(1)) $(2) $(EX_LIBS) > link.tmp
    @cat link.tmp >> $(1:.exe=.map)
    @rm -f link.tmp
    @echo
  endef

  define link_DLL
    $(call green_msg, Linking $(1))
    $(CL_LINK) -dll $(CL_LDFLAGS) -out:$(strip $(1)) -implib:$(strip $(2)) \
               -def:$(strip $(3)) $(4) $(LUAJIT_LIB) $(EX_LIBS) > link.tmp
    @cat link.tmp >> $(1:.dll=.map)
    @rm -f link.tmp $(2:.lib=.exp)
    @echo
  endef

  define make_res
    rc $(CL_RCFLAGS) -fo $(2) $(1)
    @echo
  endef
endif

define CPP_FILTER_PY
  import sys, os

  try:
    import ntpath
  except ImportError as e:
    print ("Failed to import ntpath: %s" % e)
    sys.exit(1)

  def _win32_abspath (path):
    path = ntpath.abspath (path)
    return path.replace ('\\', '/')

  def skip_cwd (s1, s2):
    ''' Skip the leading part that is in common with s1 and s2
    '''
    i = 0
    while i < len(s1) and s1[i] == s2[i]:
       i += 1
    return s2[i:]

  cwd = _win32_abspath (os.getcwd()) + '/'

  last_line  = '??'
  last_fname = '??'
  empty_lines = abs_path_done = 0

  while True:
    line = sys.stdin.readline()
    if not line:
      break
    if line.startswith('\n') or line.startswith('\r'):
      empty_lines += 1
      continue

    line  = line.replace ("\\\\", "/")
    quote = line.find ('\"')
    fname = None

    if line.startswith ("#line ") and quote > 0:
      fname = _win32_abspath (line[quote:])
      abs_path_done += 1
      last_fname = fname

    if line.strip() != '' and last_line != '':
      if fname is None or fname != last_fname:
        print (line, end="")

        if line.strip() == '}':  # Print a newline after a function
          print ("")

    last_line = line

  if empty_lines > 0:
    sys.stderr.write ("Removed %d empty lines. _win32_abspath() done %d times." % (empty_lines, abs_path_done))

endef

cpp_filter.py: $(THIS_FILE)
	$(call green_msg, Generating $@...)
	$(file >  $@,#!/usr/env/python)
	$(file >> $@,#)
	$(file >> $@,# DO NOT EDIT! This file was generated automatically)
	$(file >> $@,# from $(realpath $(THIS_FILE)). Edit that file instead.)
	$(file >> $@,#)
	$(file >> $@,from __future__ import print_function)
	$(file >> $@,if 1:)
	$(file >> $@,$(CPP_FILTER_PY))

#
# The dependency section:
#
$(OBJ_DIR)/common.$(O): common.c common.h wsock_defs.h smartlist.h init.h dump.h wsock_trace.rc

$(OBJ_DIR)/cpu.$(O): cpu.c common.h wsock_defs.h init.h cpu.h

$(OBJ_DIR)/dnsbl.$(O): dnsbl.c common.h wsock_defs.h init.h in_addr.h smartlist.h geoip.h inet_util.h dnsbl.h

$(OBJ_DIR)/dump.$(O): dump.c common.h wsock_defs.h in_addr.h init.h geoip.h smartlist.h idna.h hosts.h wsock_trace.h inet_util.h dnsbl.h dump.h

$(OBJ_DIR)/hosts.$(O): hosts.c common.h wsock_defs.h init.h smartlist.h in_addr.h hosts.h

$(OBJ_DIR)/geoip.$(O): geoip.c common.h wsock_defs.h smartlist.h init.h in_addr.h inet_util.h geoip.h

$(OBJ_DIR)/geoip-gen4.$(O): geoip-gen4.c geoip.h common.h wsock_defs.h smartlist.h init.h

$(OBJ_DIR)/geoip-gen6.$(O): geoip-gen6.c geoip.h common.h wsock_defs.h smartlist.h init.h

$(OBJ_DIR)/idna.$(O): idna.c common.h wsock_defs.h init.h smartlist.h idna.h

$(OBJ_DIR)/inet_util.$(O): inet_util.c common.h wsock_defs.h init.h in_addr.h inet_util.h

$(OBJ_DIR)/init.$(O): init.c common.h wsock_defs.h wsock_trace.h bfd_gcc.h dump.h geoip.h smartlist.h init.h idna.h stkwalk.h overlap.h hosts.h firewall.h cpu.h dnsbl.h

$(OBJ_DIR)/in_addr.$(O): in_addr.c common.h wsock_defs.h in_addr.h

$(OBJ_DIR)/ip2loc.$(O): ip2loc.c common.h wsock_defs.h init.h in_addr.h inet_util.h geoip.h smartlist.h

$(OBJ_DIR)/overlap.$(O): overlap.c common.h wsock_defs.h init.h smartlist.h overlap.h

$(OBJ_DIR)/smartlist.$(O): smartlist.c common.h wsock_defs.h vm_dump.h smartlist.h

$(OBJ_DIR)/stkwalk.$(O): stkwalk.c common.h wsock_defs.h init.h bfd_gcc.h stkwalk.h smartlist.h

$(OBJ_DIR)/vm_dump.$(O): vm_dump.c common.h wsock_defs.h cpu.h vm_dump.h

$(OBJ_DIR)/test.$(O): test.c wsock_defs.h getopt.h

$(OBJ_DIR)/wsock_trace.$(O): wsock_trace.c common.h wsock_defs.h bfd_gcc.h in_addr.h init.h cpu.h stkwalk.h smartlist.h \
                             overlap.h dump.h wsock_trace_lua.h wsock_trace.h wsock_hooks.c

ifeq ($(USE_LUA),1)
$(OBJ_DIR)/wsock_trace.$(O): $(LUAJIT_ROOT)/src/lua.h \
                             $(LUAJIT_ROOT)/src/luaconf.h \
                             $(LUAJIT_ROOT)/src/lualib.h \
                             $(LUAJIT_ROOT)/src/lua.h \
                             $(LUAJIT_ROOT)/src/lauxlib.h

$(OBJ_DIR)/wsock_trace_lua.$(O): wsock_trace_lua.c common.h wsock_defs.h init.h \
                                 wsock_trace_lua.h \
                                 $(LUAJIT_ROOT)/src/lua.h \
                                 $(LUAJIT_ROOT)/src/luaconf.h \
                                 $(LUAJIT_ROOT)/src/lualib.h \
                                 $(LUAJIT_ROOT)/src/lua.h \
                                 $(LUAJIT_ROOT)/src/lauxlib.h \
                                 $(LUAJIT_ROOT)/src/lj_arch.h
endif


